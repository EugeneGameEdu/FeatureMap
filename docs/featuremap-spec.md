# FeatureMap — Project Specification (Index)

Single source of truth for FeatureMap’s architecture and workflows, written for both humans and AI agents.

**Spec Version:** 1.1  
**Last Updated:** 2026-01-08  
**Status:** Stable core, active development

This file is intentionally kept short (<300 lines). The detailed reference lives in `docs/featuremap-spec/`.

## 1) Conceptual Model

FeatureMap represents a codebase at two abstraction levels:

- **Clusters (technical):** deterministic groupings of files (mostly folder-based) produced by the CLI.
- **Features (architectural):** AI/user groupings of clusters (e.g. “Code Analysis Engine”) persisted as YAML.

Core flow:

`Code -> CLI scan -> clusters + graph -> AI groups -> features -> web visualizes`

Key idea: AI reasons primarily over the map (`.featuremap/`), not the full codebase.

## 2) Repository Packages

Monorepo layout (current):

- `packages/cli/`: CLI, scanner/parser, local server (Express + WebSocket), YAML validation.
- `packages/mcp-server/`: MCP server exposing FeatureMap tools to AI clients.
- `packages/web/`: React visualization (React Flow) reading `featuremap-data`.

## 3) On-Disk Data Model (`.featuremap/`)

The project’s map and context live in `.featuremap/` (YAML, git-friendly):

- `config.yaml`: scan configuration + feature grouping hints.
- `clusters/*.yaml`: cluster definitions (generated, but some fields are preserved).
- `features/*.yaml`: feature definitions (authored by AI/user).
- `groups/*.yaml`: user/AI-defined collections of feature IDs (for filtering/containers).
- `comments/*.yaml`: free-form map annotations (positioned and linkable).
- `context/*.yaml`: project context for AI (some auto, some manual).
- `graph.yaml`: nodes/edges used by the web map (clusters + optional feature overlay).
- `layout.yaml`: node positions + viewport (user-edited from the web UI).

Notes:

- `context/overview.yaml` is a manual context file and should be treated like `decisions.yaml` and `constraints.yaml`.
- `raw-graph.yaml` is a validated schema but is not currently generated by `featuremap scan`.

### File Categories (Behavior)

- **Derived (regenerated):** `graph.yaml`, `context/tech-stack.yaml`, `context/conventions.yaml`
- **Authored/preserved:** `clusters/*.yaml`, `features/*.yaml`, `groups/*.yaml`, `comments/*.yaml`, `layout.yaml`, `context/{decisions,constraints,overview,design-system}.yaml`

Clusters are “preserved” because user fields (e.g. locks, hints) survive rescans even though most content is regenerated.

## 4) CLI Workflows (Summary)

- `featuremap init`: creates `.featuremap/` scaffold.
- `featuremap scan`: scans the repo, generates/updates clusters, updates derived context and `graph.yaml`.
  - `--ai`: prints an MCP connection snippet for AI-assisted grouping.
- `featuremap context init`: creates missing context templates and refreshes auto context.
- `featuremap validate`: validates `.featuremap/**/*.yaml` with Zod schemas.
- `featuremap web`: copies `.featuremap/` into the web app’s `public/featuremap-data` and runs Vite dev.
- `featuremap serve`: hosts Web UI + API + WebSocket.
  - `--dev`: uses Vite middleware and syncs data for dev.

Important: `featuremap serve` prints a **session token**; the web UI uses it for authenticated mutations (context/comments/groups/layout).

## 5) Web App (Summary)

The web app loads map data from `/featuremap-data/*` (served either by `featuremap serve` or by the dev copy step).

What “live updates” means today:

- WebSocket broadcasts when the **API** writes context/comments/groups/layout.
- It does not automatically broadcast on arbitrary filesystem changes to `.featuremap/`.

## 6) MCP Server (Summary)

Current MCP tools (see details for parameters and semantics):

- Read/navigation: `get_architecture_overview`, `get_feature_details`, `get_cluster_files`, `get_group_details`, `find_relevant_features`, `get_node_comments`, `get_current_features`, `get_project_context`, `get_grouping_input`
- Write: `save_features_from_grouping`, `update_feature`, `create_group`

AI-safe default workflow:

1. `get_project_context` (load constraints/decisions/overview/design guidance)
2. `get_grouping_input` (compact cluster map for grouping)
3. `get_current_features` (avoid duplicate/redundant features)
4. `save_features_from_grouping` (persist features + rebuild graph overlay)

## 7) Detailed Reference (Links)

- CLI & config: `docs/featuremap-spec/cli.md`
- MCP tools & client setup: `docs/featuremap-spec/mcp-tools.md`
- YAML formats & field reference: `docs/featuremap-spec/yaml-formats.md`
- Web UI behavior & live updates: `docs/featuremap-spec/web-ui.md`
- Troubleshooting: `docs/featuremap-spec/troubleshooting.md`
- Roadmap: `docs/featuremap-spec/roadmap.md`

## 8) Development Rules (Project Conventions)

- File size: keep files under ~300 lines; split by responsibility.
- Prefer pure functions and composition over classes.
- After modifying:
  - `packages/web/**`: `npm run build --workspace=@featuremap/web`
  - `packages/cli/**`: `npm run build --workspace=@featuremap/cli`
  - `packages/mcp-server/**`: `npm run build --workspace=@featuremap/mcp-server`
